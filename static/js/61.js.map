{"version":3,"file":"static/js/61.js","sources":["webpack:///./node_modules/_maptalks.markercluster@0.8.3@maptalks.markercluster/dist/maptalks.markercluster.es.js"],"sourcesContent":["/*!\n * maptalks.markercluster v0.8.3\n * LICENSE : MIT\n * (c) 2016-2019 maptalks.org\n */\n/*!\n * requires maptalks@>=0.26.3 \n */\nimport { Canvas, Coordinate, Geometry, MapboxUtil, Marker, Point, PointExtent, StringUtil, Util, VectorLayer, animation, renderer } from 'maptalks';\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }\n\nvar options = {\n    'maxClusterRadius': 160,\n    'textSumProperty': null,\n    'symbol': null,\n    'drawClusterText': true,\n    'textSymbol': null,\n    'animation': true,\n    'animationDuration': 450,\n    'maxClusterZoom': null,\n    'noClusterWithOneMarker': true,\n    'forceRenderOnZooming': true\n};\n\nvar ClusterLayer = function (_maptalks$VectorLayer) {\n    _inherits(ClusterLayer, _maptalks$VectorLayer);\n\n    function ClusterLayer() {\n        _classCallCheck(this, ClusterLayer);\n\n        return _possibleConstructorReturn(this, _maptalks$VectorLayer.apply(this, arguments));\n    }\n\n    /**\n     * Reproduce a ClusterLayer from layer's profile JSON.\n     * @param  {Object} json - layer's profile JSON\n     * @return {maptalks.ClusterLayer}\n     * @static\n     * @private\n     * @function\n     */\n    ClusterLayer.fromJSON = function fromJSON(json) {\n        if (!json || json['type'] !== 'ClusterLayer') {\n            return null;\n        }\n        var layer = new ClusterLayer(json['id'], json['options']);\n        var geoJSONs = json['geometries'];\n        var geometries = [];\n        for (var i = 0; i < geoJSONs.length; i++) {\n            var geo = Geometry.fromJSON(geoJSONs[i]);\n            if (geo) {\n                geometries.push(geo);\n            }\n        }\n        layer.addGeometry(geometries);\n        return layer;\n    };\n\n    ClusterLayer.prototype.addMarker = function addMarker(markers) {\n        return this.addGeometry(markers);\n    };\n\n    ClusterLayer.prototype.addGeometry = function addGeometry(markers) {\n        for (var i = 0, len = markers.length; i <= len; i++) {\n            if (!markers[i] instanceof Marker) {\n                throw new Error('Only a point(Marker) can be added into a ClusterLayer');\n            }\n        }\n        return _maptalks$VectorLayer.prototype.addGeometry.apply(this, arguments);\n    };\n\n    ClusterLayer.prototype.onConfig = function onConfig(conf) {\n        _maptalks$VectorLayer.prototype.onConfig.call(this, conf);\n        if (conf['maxClusterRadius'] || conf['symbol'] || conf['drawClusterText'] || conf['textSymbol'] || conf['maxClusterZoom']) {\n            var renderer$$1 = this._getRenderer();\n            if (renderer$$1) {\n                renderer$$1.render();\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Identify the clusters on the given coordinate\n     * @param  {maptalks.Coordinate} coordinate   - coordinate to identify\n     * @return {Object|Geometry[]}  result: cluster { center : [cluster's center], children : [geometries in the cluster] } or markers\n     */\n\n\n    ClusterLayer.prototype.identify = function identify(coordinate, options) {\n        var map = this.getMap(),\n            maxZoom = this.options['maxClusterZoom'];\n        if (maxZoom && map && map.getZoom() > maxZoom) {\n            return _maptalks$VectorLayer.prototype.identify.call(this, coordinate, options);\n        }\n        if (this._getRenderer()) {\n            return this._getRenderer().identify(coordinate, options);\n        }\n        return null;\n    };\n\n    /**\n     * Export the ClusterLayer's JSON.\n     * @return {Object} layer's JSON\n     */\n\n\n    ClusterLayer.prototype.toJSON = function toJSON() {\n        var json = _maptalks$VectorLayer.prototype.toJSON.call(this);\n        json['type'] = 'ClusterLayer';\n        return json;\n    };\n    /**\n     * Get the ClusterLayer's current clusters\n     * @return {Object} layer's clusters\n     **/\n\n\n    ClusterLayer.prototype.getClusters = function getClusters() {\n        var renderer$$1 = this._getRenderer();\n        if (renderer$$1) {\n            return renderer$$1._currentClusters || [];\n        }\n        return [];\n    };\n\n    return ClusterLayer;\n}(VectorLayer);\n\n// merge to define ClusterLayer's default options.\nClusterLayer.mergeOptions(options);\n\n// register ClusterLayer's JSON type for JSON deserialization.\nClusterLayer.registerJSONType('ClusterLayer');\n\nvar defaultTextSymbol = {\n    'textFaceName': '\"microsoft yahei\"',\n    'textSize': 16,\n    'textDx': 0,\n    'textDy': 0\n};\n\nvar defaultSymbol = {\n    'markerType': 'ellipse',\n    'markerFill': { property: 'count', type: 'interval', stops: [[0, 'rgb(135, 196, 240)'], [9, '#1bbc9b'], [99, 'rgb(216, 115, 149)']] },\n    'markerFillOpacity': 0.7,\n    'markerLineOpacity': 1,\n    'markerLineWidth': 3,\n    'markerLineColor': '#fff',\n    'markerWidth': { property: 'count', type: 'interval', stops: [[0, 40], [9, 60], [99, 80]] },\n    'markerHeight': { property: 'count', type: 'interval', stops: [[0, 40], [9, 60], [99, 80]] }\n};\n\nClusterLayer.registerRenderer('canvas', function (_maptalks$renderer$Ve) {\n    _inherits(_class, _maptalks$renderer$Ve);\n\n    function _class(layer) {\n        _classCallCheck(this, _class);\n\n        var _this2 = _possibleConstructorReturn(this, _maptalks$renderer$Ve.call(this, layer));\n\n        _this2._animated = true;\n        _this2._refreshStyle();\n        _this2._clusterNeedRedraw = true;\n        return _this2;\n    }\n\n    _class.prototype.checkResources = function checkResources() {\n        var symbol = this.layer.options['symbol'] || defaultSymbol;\n        var resources = _maptalks$renderer$Ve.prototype.checkResources.apply(this, arguments);\n        if (symbol !== this._symbolResourceChecked) {\n            var res = Util.getExternalResources(symbol, true);\n            if (res) {\n                resources.push.apply(resources, res);\n            }\n            this._symbolResourceChecked = symbol;\n        }\n        return resources;\n    };\n\n    _class.prototype.draw = function draw() {\n        if (!this.canvas) {\n            this.prepareCanvas();\n        }\n        var map = this.getMap();\n        var zoom = map.getZoom();\n        var maxClusterZoom = this.layer.options['maxClusterZoom'];\n        if (maxClusterZoom && zoom > maxClusterZoom) {\n            delete this._currentClusters;\n            this._markersToDraw = this.layer._geoList;\n            _maptalks$renderer$Ve.prototype.draw.apply(this, arguments);\n            return;\n        }\n        if (this._clusterNeedRedraw) {\n            this._clearDataCache();\n            this._computeGrid();\n            this._clusterNeedRedraw = false;\n        }\n        var zoomClusters = this._clusterCache[zoom] ? this._clusterCache[zoom]['clusters'] : null;\n\n        var clusters = this._getClustersToDraw(zoomClusters);\n        clusters.zoom = zoom;\n        this._drawLayer(clusters);\n    };\n\n    _class.prototype._getClustersToDraw = function _getClustersToDraw(zoomClusters) {\n        this._markersToDraw = [];\n        var map = this.getMap();\n        var font = StringUtil.getFont(this._textSymbol),\n            digitLen = StringUtil.stringLength('9', font).toPoint();\n        var extent = map.getContainerExtent(),\n            clusters = [];\n        var pt = void 0,\n            pExt = void 0,\n            sprite = void 0,\n            width = void 0,\n            height = void 0;\n        for (var p in zoomClusters) {\n            this._currentGrid = zoomClusters[p];\n            if (zoomClusters[p]['count'] === 1 && this.layer.options['noClusterWithOneMarker']) {\n                var marker = zoomClusters[p]['children'][0];\n                marker._cluster = zoomClusters[p];\n                this._markersToDraw.push(marker);\n                continue;\n            }\n            sprite = this._getSprite();\n            width = sprite.canvas.width;\n            height = sprite.canvas.height;\n            pt = map._prjToContainerPoint(zoomClusters[p]['center']);\n            pExt = new PointExtent(pt.sub(width, height), pt.add(width, height));\n            if (!extent.intersects(pExt)) {\n                continue;\n            }\n\n            if (!zoomClusters[p]['textSize']) {\n                var text = this._getClusterText(zoomClusters[p]);\n                zoomClusters[p]['textSize'] = new Point(digitLen.x * text.length, digitLen.y)._multi(1 / 2);\n            }\n            clusters.push(zoomClusters[p]);\n        }\n        return clusters;\n    };\n\n    _class.prototype.drawOnInteracting = function drawOnInteracting() {\n        if (this._currentClusters) {\n            this._drawClusters(this._currentClusters, 1);\n        }\n        _maptalks$renderer$Ve.prototype.drawOnInteracting.apply(this, arguments);\n    };\n\n    _class.prototype.forEachGeo = function forEachGeo(fn, context) {\n        if (this._markersToDraw) {\n            this._markersToDraw.forEach(function (g) {\n                if (context) {\n                    fn.call(context, g);\n                } else {\n                    fn(g);\n                }\n            });\n        }\n    };\n\n    _class.prototype.onGeometryShow = function onGeometryShow() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryShow.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryHide = function onGeometryHide() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryHide.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryAdd = function onGeometryAdd() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryAdd.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryRemove = function onGeometryRemove() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryRemove.apply(this, arguments);\n    };\n\n    _class.prototype.onGeometryPositionChange = function onGeometryPositionChange() {\n        this._clusterNeedRedraw = true;\n        _maptalks$renderer$Ve.prototype.onGeometryPositionChange.apply(this, arguments);\n    };\n\n    _class.prototype.onRemove = function onRemove() {\n        this._clearDataCache();\n    };\n\n    _class.prototype.identify = function identify(coordinate, options) {\n        var map = this.getMap(),\n            maxZoom = this.layer.options['maxClusterZoom'];\n        if (maxZoom && map.getZoom() > maxZoom) {\n            return _maptalks$renderer$Ve.prototype.identify.call(this, coordinate, options);\n        }\n        if (this._currentClusters) {\n            var point = map.coordinateToContainerPoint(coordinate);\n            var old = this._currentGrid;\n            for (var i = 0; i < this._currentClusters.length; i++) {\n                var c = this._currentClusters[i];\n                var pt = map._prjToContainerPoint(c['center']);\n                this._currentGrid = c;\n                var markerWidth = this._getSprite().canvas.width;\n\n                if (point.distanceTo(pt) <= markerWidth) {\n                    return {\n                        'center': map.getProjection().unproject(c.center.copy()),\n                        'children': c.children.slice(0)\n                    };\n                }\n            }\n            this._currentGrid = old;\n        }\n\n        // if no clusters is hit, identify markers\n        if (this._markersToDraw) {\n            return this.layer._hitGeos(this._markersToDraw, coordinate, options);\n        }\n        return null;\n    };\n\n    _class.prototype.onSymbolChanged = function onSymbolChanged() {\n        this._refreshStyle();\n        this._computeGrid();\n        this._stopAnim();\n        this.setToRedraw();\n    };\n\n    _class.prototype._refreshStyle = function _refreshStyle() {\n        var _this3 = this;\n\n        var symbol = this.layer.options['symbol'] || defaultSymbol;\n        var textSymbol = this.layer.options['textSymbol'] || defaultTextSymbol;\n        var argFn = function argFn() {\n            return [_this3.getMap().getZoom(), _this3._currentGrid];\n        };\n        this._symbol = MapboxUtil.loadFunctionTypes(symbol, argFn);\n        this._textSymbol = MapboxUtil.loadFunctionTypes(textSymbol, argFn);\n    };\n\n    _class.prototype._drawLayer = function _drawLayer(clusters) {\n        var _this4 = this;\n\n        var parentClusters = this._currentClusters || clusters;\n        this._currentClusters = clusters;\n        delete this._clusterMaskExtent;\n        var layer = this.layer;\n        //if (layer.options['animation'] && this._animated && this._inout === 'out') {\n        if (layer.options['animation'] && this._animated && this._inout) {\n            var dr = [0, 1];\n            if (this._inout === 'in') {\n                dr = [1, 0];\n            }\n            this._player = animation.Animation.animate({ 'd': dr }, { 'speed': layer.options['animationDuration'], 'easing': 'inAndOut' }, function (frame) {\n                if (frame.state.playState === 'finished') {\n                    _this4._animated = false;\n                    _this4._drawClusters(clusters, 1);\n                    _this4._drawMarkers();\n                    _this4.completeRender();\n                } else {\n                    if (_this4._inout === 'in') {\n                        _this4._drawClustersFrame(clusters, parentClusters, frame.styles.d);\n                    } else {\n                        _this4._drawClustersFrame(parentClusters, clusters, frame.styles.d);\n                    }\n                    _this4.setCanvasUpdated();\n                }\n            }).play();\n        } else {\n            this._animated = false;\n            this._drawClusters(clusters, 1);\n            this._drawMarkers();\n            this.completeRender();\n        }\n    };\n\n    _class.prototype._drawMarkers = function _drawMarkers() {\n        _maptalks$renderer$Ve.prototype.drawGeos.call(this, this._clusterMaskExtent);\n    };\n\n    _class.prototype._drawClustersFrame = function _drawClustersFrame(parentClusters, toClusters, ratio) {\n        var _this5 = this;\n\n        this._clusterMaskExtent = this.prepareCanvas();\n        var map = this.getMap(),\n            drawn = {};\n        if (parentClusters) {\n            parentClusters.forEach(function (c) {\n                var p = map._prjToContainerPoint(c['center']);\n                if (!drawn[c.key]) {\n                    drawn[c.key] = 1;\n                    _this5._drawCluster(p, c, 1 - ratio);\n                }\n            });\n        }\n        if (ratio === 0 || !toClusters) {\n            return;\n        }\n        var z = parentClusters.zoom,\n            r = map._getResolution(z) * this.layer.options['maxClusterRadius'],\n            min = this._markerExtent.getMin();\n        toClusters.forEach(function (c) {\n            var pt = map._prjToContainerPoint(c['center']);\n            var center = c.center;\n            var pgx = Math.floor((center.x - min.x) / r),\n                pgy = Math.floor((center.y - min.y) / r);\n            var pkey = pgx + '_' + pgy;\n            var parent = _this5._clusterCache[z]['clusterMap'][pkey];\n            if (parent) {\n                var pp = map._prjToContainerPoint(parent['center']);\n                pt = pp.add(pt.sub(pp)._multi(ratio));\n            }\n            _this5._drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n        });\n    };\n\n    _class.prototype._drawClusters = function _drawClusters(clusters, ratio) {\n        var _this6 = this;\n\n        if (!clusters) {\n            return;\n        }\n        this._clusterMaskExtent = this.prepareCanvas();\n        var map = this.getMap();\n        clusters.forEach(function (c) {\n            var pt = map._prjToContainerPoint(c['center']);\n            _this6._drawCluster(pt, c, ratio > 0.5 ? 1 : ratio);\n        });\n    };\n\n    _class.prototype._drawCluster = function _drawCluster(pt, cluster, op) {\n        this._currentGrid = cluster;\n        var ctx = this.context;\n        var sprite = this._getSprite();\n        var opacity = ctx.globalAlpha;\n        if (opacity * op === 0) {\n            return;\n        }\n        ctx.globalAlpha = opacity * op;\n        if (sprite) {\n            var pos = pt.add(sprite.offset)._sub(sprite.canvas.width / 2, sprite.canvas.height / 2);\n            ctx.drawImage(sprite.canvas, pos.x, pos.y);\n        }\n\n        if (this.layer.options['drawClusterText'] && cluster['textSize']) {\n            Canvas.prepareCanvasFont(ctx, this._textSymbol);\n            ctx.textBaseline = 'middle';\n            var dx = this._textSymbol['textDx'] || 0;\n            var dy = this._textSymbol['textDy'] || 0;\n            var text = this._getClusterText(cluster);\n            Canvas.fillText(ctx, text, pt.sub(cluster['textSize'].x, 0)._add(dx, dy));\n        }\n        ctx.globalAlpha = opacity;\n    };\n\n    _class.prototype._getClusterText = function _getClusterText(cluster) {\n        var text = this.layer.options['textSumProperty'] ? cluster['textSumProperty'] : cluster['count'];\n        return text + '';\n    };\n\n    _class.prototype._getSprite = function _getSprite() {\n        if (!this._spriteCache) {\n            this._spriteCache = {};\n        }\n        var key = Util.getSymbolStamp(this._symbol);\n        if (!this._spriteCache[key]) {\n            this._spriteCache[key] = new Marker([0, 0], { 'symbol': this._symbol })._getSprite(this.resources, this.getMap().CanvasClass);\n        }\n        return this._spriteCache[key];\n    };\n\n    _class.prototype._initGridSystem = function _initGridSystem() {\n        var points = [];\n        var extent = void 0,\n            c = void 0;\n        this.layer.forEach(function (g) {\n            if (!g.isVisible()) {\n                return;\n            }\n            c = g._getPrjCoordinates();\n            if (!extent) {\n                extent = g._getPrjExtent();\n            } else {\n                extent = extent._combine(g._getPrjExtent());\n            }\n            points.push({\n                x: c.x,\n                y: c.y,\n                id: g._getInternalId(),\n                geometry: g\n            });\n        });\n        this._markerExtent = extent;\n        this._markerPoints = points;\n    };\n\n    _class.prototype._computeGrid = function _computeGrid() {\n        var map = this.getMap(),\n            zoom = map.getZoom();\n        if (!this._markerExtent) {\n            this._initGridSystem();\n        }\n        if (!this._clusterCache) {\n            this._clusterCache = {};\n        }\n        var pre = map._getResolution(map.getMinZoom()) > map._getResolution(map.getMaxZoom()) ? zoom - 1 : zoom + 1;\n        if (this._clusterCache[pre] && this._clusterCache[pre].length === this.layer.getCount()) {\n            this._clusterCache[zoom] = this._clusterCache[pre];\n        }\n        if (!this._clusterCache[zoom]) {\n            this._clusterCache[zoom] = this._computeZoomGrid(zoom);\n        }\n    };\n\n    _class.prototype._computeZoomGrid = function _computeZoomGrid(zoom) {\n        if (!this._markerExtent) {\n            return null;\n        }\n        var map = this.getMap(),\n            r = map._getResolution(zoom) * this.layer.options['maxClusterRadius'],\n            preT = map._getResolution(zoom - 1) ? map._getResolution(zoom - 1) * this.layer.options['maxClusterRadius'] : null;\n        var preCache = this._clusterCache[zoom - 1];\n        if (!preCache && zoom - 1 >= map.getMinZoom()) {\n            this._clusterCache[zoom - 1] = preCache = this._computeZoomGrid(zoom - 1);\n        }\n        // 1. format extent of markers to grids with raidus of r\n        // 2. find point's grid in the grids\n        // 3. sum up the point into the grid's collection\n        var points = this._markerPoints;\n        var sumProperty = this.layer.options['textSumProperty'];\n        var grids = {},\n            min = this._markerExtent.getMin();\n        var gx = void 0,\n            gy = void 0,\n            key = void 0,\n            pgx = void 0,\n            pgy = void 0,\n            pkey = void 0;\n        for (var i = 0, len = points.length; i < len; i++) {\n            var geo = points[i].geometry;\n            var sumProp = 0;\n\n            if (sumProperty && geo.getProperties() && geo.getProperties()[sumProperty]) {\n                sumProp = geo.getProperties()[sumProperty];\n            }\n\n            gx = Math.floor((points[i].x - min.x) / r);\n            gy = Math.floor((points[i].y - min.y) / r);\n            key = gx + '_' + gy;\n            if (!grids[key]) {\n                grids[key] = {\n                    'sum': new Coordinate(points[i].x, points[i].y),\n                    'center': new Coordinate(points[i].x, points[i].y),\n                    'count': 1,\n                    'textSumProperty': sumProp,\n                    'children': [geo],\n                    'key': key + ''\n                };\n                if (preT && preCache) {\n                    pgx = Math.floor((points[i].x - min.x) / preT);\n                    pgy = Math.floor((points[i].y - min.y) / preT);\n                    pkey = pgx + '_' + pgy;\n                    grids[key]['parent'] = preCache['clusterMap'][pkey];\n                }\n            } else {\n\n                grids[key]['sum']._add(new Coordinate(points[i].x, points[i].y));\n                grids[key]['count']++;\n                grids[key]['center'] = grids[key]['sum'].multi(1 / grids[key]['count']);\n                grids[key]['children'].push(geo);\n                grids[key]['textSumProperty'] += sumProp;\n            }\n        }\n        return this._mergeClusters(grids, r / 2);\n    };\n\n    _class.prototype._mergeClusters = function _mergeClusters(grids, r) {\n        var clusterMap = {};\n        for (var p in grids) {\n            clusterMap[p] = grids[p];\n        }\n\n        // merge adjacent clusters\n        var merging = {};\n\n        var visited = {};\n        // find clusters need to merge\n        var c1 = void 0,\n            c2 = void 0;\n        for (var _p in grids) {\n            c1 = grids[_p];\n            if (visited[c1.key]) {\n                continue;\n            }\n            var gxgy = c1.key.split('_');\n            var gx = +gxgy[0],\n                gy = +gxgy[1];\n            //traverse adjacent grids\n            for (var ii = -1; ii <= 1; ii++) {\n                for (var iii = -1; iii <= 1; iii++) {\n                    if (ii === 0 && iii === 0) {\n                        continue;\n                    }\n                    var key2 = gx + ii + '_' + (gy + iii);\n                    c2 = grids[key2];\n                    if (c2 && this._distanceTo(c1['center'], c2['center']) <= r) {\n                        if (!merging[c1.key]) {\n                            merging[c1.key] = [];\n                        }\n                        merging[c1.key].push(c2);\n                        visited[c2.key] = 1;\n                    }\n                }\n            }\n        }\n\n        //merge clusters\n        for (var m in merging) {\n            var grid = grids[m];\n            if (!grid) {\n                continue;\n            }\n            var toMerge = merging[m];\n            for (var i = 0; i < toMerge.length; i++) {\n                if (grids[toMerge[i].key]) {\n                    grid['sum']._add(toMerge[i].sum);\n                    grid['count'] += toMerge[i].count;\n                    grid['textSumProperty'] += toMerge[i].textSumProperty;\n                    grid['children'] = grid['children'].concat(toMerge[i].children);\n                    clusterMap[toMerge[i].key] = grid;\n                    delete grids[toMerge[i].key];\n                }\n            }\n            grid['center'] = grid['sum'].multi(1 / grid['count']);\n        }\n\n        return {\n            'clusters': grids,\n            'clusterMap': clusterMap\n        };\n    };\n\n    _class.prototype._distanceTo = function _distanceTo(c1, c2) {\n        var x = c1.x - c2.x,\n            y = c1.y - c2.y;\n        return Math.sqrt(x * x + y * y);\n    };\n\n    _class.prototype._stopAnim = function _stopAnim() {\n        if (this._player && this._player.playState !== 'finished') {\n            this._player.finish();\n        }\n    };\n\n    _class.prototype.onZoomStart = function onZoomStart(param) {\n        this._stopAnim();\n        _maptalks$renderer$Ve.prototype.onZoomStart.call(this, param);\n    };\n\n    _class.prototype.onZoomEnd = function onZoomEnd(param) {\n        if (this.layer.isEmpty() || !this.layer.isVisible()) {\n            _maptalks$renderer$Ve.prototype.onZoomEnd.apply(this, arguments);\n            return;\n        }\n        this._inout = param['from'] > param['to'] ? 'in' : 'out';\n        this._animated = true;\n        this._computeGrid();\n        _maptalks$renderer$Ve.prototype.onZoomEnd.apply(this, arguments);\n    };\n\n    _class.prototype._clearDataCache = function _clearDataCache() {\n        this._stopAnim();\n        delete this._markerExtent;\n        delete this._markerPoints;\n        delete this._clusterCache;\n        delete this._zoomInClusters;\n    };\n\n    return _class;\n}(renderer.VectorLayerCanvasRenderer));\n\nexport { ClusterLayer };\n\ntypeof console !== 'undefined' && console.log('maptalks.markercluster v0.8.3, requires maptalks@>=0.26.3.');\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}